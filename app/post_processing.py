import pandas as pd

class PostProcessor: 

    def generate_misclassification_mask(self, df, column_to_mask='predicted', chunk_size=60, threshold=0.3):
        """
        Apply a binary mask to each row in a DataFrame based on the average value of a specified column in chunks.

        Args:
            df (pd.DataFrame): DataFrame containing the data.
            column_to_mask (str): Name of the column to calculate the mean and apply the mask.
            chunk_size (int): Size of the chunks to divide the DataFrame into.
            threshold (float): Threshold value for determining the mask value.

        Returns:
            tuple: A tuple containing the updated DataFrame with the mask applied and the event log.
        """

        # Check if the 'mask' column already exists
        if 'mask' in df.columns:
            raise ValueError("The 'mask' column already exists in the DataFrame.")

        # Initialize the event log
        event_log = {}

        # Calculate the total number of chunks
        total_chunks = len(df) // chunk_size
        remainder = len(df) % chunk_size

        # Process each chunk
        for i in range(total_chunks):
            start_index = i * chunk_size
            end_index = start_index + chunk_size

            # Calculate the mean of the chunk and create the mask
            mean_value = df[column_to_mask].iloc[start_index:end_index].mean()
            mask_value =  1 if mean_value >= threshold else  0

            # Update the DataFrame with the mask value
            df.loc[start_index:end_index, 'mask'] = mask_value

            # Record the event log
            event_log[i] = (start_index, end_index, mask_value)

        # Process the remainder if any
        if remainder >  0:
            start_index = total_chunks * chunk_size
            end_index = len(df)

            # Calculate the mean of the remainder and create the mask
            mean_value = df[column_to_mask].iloc[start_index:end_index].mean()
            mask_value =  1 if mean_value >= threshold else  0

            # Update the DataFrame with the mask value
            df.loc[start_index:end_index, 'mask'] = mask_value

            # Record the event log for the remainder
            event_log[total_chunks] = (start_index, end_index, mask_value)

        # Return the updated DataFrame and the event log
        return df, event_log


    def on_lift_event_identification(self, df, event_log):
        """
        Identify continuous events in a DataFrame based on an event log and assign a unique label to each event.

        Args:
            df (pd.DataFrame): DataFrame containing the data.
            event_log (dict): Event log generated by the generate_misclassification_mask function.

        Returns:
            pd.DataFrame: The updated DataFrame with a new 'event' column indicating the event label for each row.
        """
        # Validate the event log
        if not isinstance(event_log, dict) or not all(isinstance(v, tuple) and len(v) ==  3 for v in event_log.values()):
            raise ValueError("Invalid event log format.")

        continuous_events_dict = {}
        event_index = 1

        start = None
        end = None

        for key in sorted(event_log.keys()):
            if event_log[key][2] > 0:
                if start is None:
                    start = event_log[key][0]
                    end = event_log[key][1]
                elif end == event_log[key][0]:
                    end = event_log[key][1]
                else:
                    continuous_events_dict[event_index] = (start, end)
                    event_index += 1
                    start, end, _ = event_log[key]

        continuous_events_dict[event_index] = (start, end)
        event_index +=  1
        start = None
        end = None

        # Assign event labels to the DataFrame
        df['event'] = 0
        for label in continuous_events_dict:
            range_val = [x for x in range(continuous_events_dict[label][0], continuous_events_dict[label][1] + 1)]
            df.loc[range_val, 'event'] = label

        return df
